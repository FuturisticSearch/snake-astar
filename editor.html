<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Blue Snake AI</title>
<style>
:root {--bg:#111;--panel:#222;--accent:#00aaff;}
body {margin:0;font-family:Arial,Helvetica,sans-serif;background:var(--panel);color:#fff;display:flex;flex-direction:column;align-items:center;padding:12px;}
h1 {margin:6px 0 14px 0;font-size:1.5rem;text-align:center;}
.controls {display:flex;flex-wrap:wrap;gap:10px;align-items:center;justify-content:center;}
label {font-size:14px;}
input[type="number"] {width:60px;padding:6px;border-radius:6px;border:none;text-align:center;}
input[type="range"] {width:140px;}
button {background:var(--accent);color:#04111a;border:none;padding:10px 14px;border-radius:8px;font-size:14px;cursor:pointer;}
button:hover {opacity:.95;}
button.active {background:#00ff88;color:#04111a;}
#gameArea {position:relative;margin-top:12px;width:100%;max-width:600px;}
canvas {background:var(--bg);border:3px solid var(--accent);border-radius:8px;display:block;width:100%;height:auto;}
#hud {margin-top:10px;display:flex;gap:12px;align-items:center;flex-wrap:wrap;justify-content:center;}
#overlay {position:absolute;left:0;top:0;width:100%;height:100%;background:rgba(0,0,0,0.75);display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:5;display:none;text-align:center;}
#overlayText {font-size:2rem;margin-bottom:12px;}
#calcPanel {font-size:12px;line-height:1.2;white-space:pre;max-height:200px;overflow:auto;margin-top:8px;width:90%;}
</style>
</head>
<body>
<h1>Blue Snake AI</h1>

<div class="controls">
  <label>Map size: <input id="mapSize" type="number" min="5" max="80" value="15"></label>
  <label>Apples: <input id="appleCount" type="number" min="1" max="50" value="5"></label>
  <label>Mode: 
    <select id="aiMode">
      <option value="safe">Safe</option>
      <option value="greedy">Greedy</option>
    </select>
  </label>
  <label>Speed: <input id="speed" type="range" min="30" max="300" value="120"> <span id="speedVal">120ms</span></label>
  <button id="playAgain">Play Again</button>
  <button id="pauseBtn">Pause</button>
  <button id="trainBtn">Train</button>
  <button id="toggleCalcBtn">Show AI Calculations</button>
</div>

<div id="gameArea">
  <canvas id="canvas"></canvas>
  <div id="overlay"><div id="overlayText"></div><button id="overlayBtn">Play Again</button></div>
</div>

<div id="hud">
  <div>Score: <span id="score">0</span></div>
  <div>Avg: <span id="avg">0</span></div>
</div>

<div id="calcPanel" style="display:none"></div>

<audio id="eatSound" src="/sound/eated.mp3"></audio>
<audio id="gameOverSound" src="/sound/gameover.mp3"></audio>

<script>
// ----- Elements -----
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const mapSizeInput = document.getElementById('mapSize');
const appleInput = document.getElementById('appleCount');
const aiModeSelect = document.getElementById('aiMode');
const playAgainBtn = document.getElementById('playAgain');
const overlay = document.getElementById('overlay');
const overlayText = document.getElementById('overlayText');
const overlayBtn = document.getElementById('overlayBtn');
const scoreEl = document.getElementById('score');
const avgScoreEl = document.getElementById('avg');
const speedRange = document.getElementById('speed');
const speedVal = document.getElementById('speedVal');
const pauseBtn = document.getElementById('pauseBtn');
const trainBtn = document.getElementById('trainBtn');
const calcPanel = document.getElementById('calcPanel');
const eatSound = document.getElementById('eatSound');
const gameOverSound = document.getElementById('gameOverSound');

// ----- Config -----
let box=32, gridSize, appleCount, snake, apples, dir, lastTick=0, intervalMs=120, score=0;
let paused=false, trainingEnabled=false;
let debugPaths=[], debugScores=[];
const DIRS={UP:[0,-1],DOWN:[0,1],LEFT:[-1,0],RIGHT:[1,0]};
let learningData={}, tempLearning={};
let avgScore=0, gamesPlayed=0;
const batchSize=5000;
let tickCount = 0;

// ----- Utils -----
function keyOf(x,y){return `${x},${y}`;}
function collidesWithSnake(x,y){return snake.some(s=>s.x===x && s.y===y);}

// superbase setup 

<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.36.0/dist/umd/supabase.min.js"></script>
<script>
const supabaseUrl = 'https://akmabafqvtltrrwvxmzz.supabase.co';
const supabaseKey = '3c98e1023235f1f14751f89490f3003b';
const supabase = supabase.createClient(supabaseUrl, supabaseKey);

// ----- Canvas setup -----
function setupCanvas(){
  gridSize = Math.max(5,Math.min(50,parseInt(mapSizeInput.value)||15));
  appleCount = Math.max(1,Math.min(20,parseInt(appleInput.value)||5));
  box = Math.floor(Math.min(window.innerWidth*0.9,600)/gridSize);
  canvas.width = canvas.height = box*gridSize;
  calcPanel.style.width = canvas.width+'px';
}

// ----- Spawn apple with yellow fruit -----
function spawnApple(){
  let attempts=0;
  while(attempts<2000){
    const x=Math.floor(Math.random()*gridSize), y=Math.floor(Math.random()*gridSize);
    if(!collidesWithSnake(x,y) && !apples.some(a=>a.x===x && a.y===y)){
      let type = Math.random() < 0.2 ? 'yellow' : 'red';
      apples.push({x,y,type});
      return;
    }
    attempts++;
  }
}

// ----- AI + A* Pathfinding -----
function floodFillCount(sx,sy,snakeBody,limit=1000){
  const visited=new Set(), bodySet=new Set(snakeBody.map(s=>keyOf(s.x,s.y)));
  const q=[{x:sx,y:sy}]; let cnt=0;
  while(q.length && cnt<limit){
    const p=q.shift(); const k=keyOf(p.x,p.y);
    if(visited.has(k)) continue;
    if(p.x<0||p.x>=gridSize||p.y<0||p.y>=gridSize) continue;
    if(bodySet.has(k)) continue;
    visited.add(k); cnt++;
    q.push({x:p.x+1,y:p.y}); q.push({x:p.x-1,y:p.y});
    q.push({x:p.x,y:p.y+1}); q.push({x:p.x,y:p.y-1});
  }
  return cnt;
}

function aStarPath(start,target,snakeBody){
  const bodySet=new Set(snakeBody.map(s=>keyOf(s.x,s.y)));
  const h=(x,y)=>Math.abs(x-target.x)+Math.abs(y-target.y);
  const open=new Map(), closed=new Set();
  open.set(keyOf(start.x,start.y), {x:start.x,y:start.y,g:0,f:h(start.x,start.y),parent:null,move:null});
  while(open.size){
    let current, currentK;
    for(const [k,n] of open){if(!current || n.f<current.f){current=n; currentK=k;}}
    open.delete(currentK); closed.add(currentK);
    if(current.x===target.x && current.y===target.y){
      const out=[]; let node=current;
      while(node.parent){ out.unshift(node.move); node=node.parent; }
      return out;
    }
    for(const [dx,dy,name] of [[0,-1,'UP'],[0,1,'DOWN'],[-1,0,'LEFT'],[1,0,'RIGHT']]){
      const nx=current.x+dx, ny=current.y+dy;
      if(nx<0||nx>=gridSize||ny<0||ny>=gridSize) continue;
      if(closed.has(keyOf(nx,ny))) continue;
      if(bodySet.has(keyOf(nx,ny)) && !(nx===target.x&&ny===target.y)) continue;
      const ng=current.g+1;
      if(!open.has(keyOf(nx,ny)) || ng<open.get(keyOf(nx,ny)).g){
        open.set(keyOf(nx,ny),{x:nx,y:ny,g:ng,f:ng+h(nx,ny),parent:current,move:name});
      }
    }
  }
  return [];
}

function safeFallbackMove(){
  for(const mv of ['UP','RIGHT','DOWN','LEFT']){
    const d=DIRS[mv]; const nx=snake[0].x+d[0], ny=snake[0].y+d[1];
    if(nx>=0 && nx<gridSize && ny>=0 && ny<gridSize && !collidesWithSnake(nx,ny)) return mv;
  }
  return dir;
}

function chooseAIMove(){
  debugPaths=[]; debugScores=[];
  const stateKey=getStateKey();
  const forbiddenMoves = learningData[stateKey]||[];
  const start={x:snake[0].x,y:snake[0].y};
  let bestScore=-Infinity, bestMove=null, bestPath=[];
  for(const apple of apples){
    const path=aStarPath(start,apple,snake);
    if(!path.length) continue;
    let simSnake = snake.map(s=>({x:s.x,y:s.y})), simHead={x:simSnake[0].x,y:simSnake[0].y};
    const pathScores=[];
    path.forEach((mv)=>{
      const dxy=DIRS[mv];
      simHead={x:simHead.x+dxy[0],y:simHead.y+dxy[1]};
      simSnake.unshift({...simHead}); simSnake.pop();
      let scoreVal=0;
      if(aiModeSelect.value==='safe'){ scoreVal+=10; if(collidesWithSnake(simHead.x,simHead.y)) scoreVal-=15; }
      if(apple.type==='yellow') scoreVal+=30;
      pathScores.push(scoreVal);
    });
    debugPaths.push({path,apple,isChosen:false});
    debugScores.push({path,apple,pathScores});
    const finalScore=pathScores[pathScores.length-1]||0;
    if(finalScore>bestScore && !forbiddenMoves.includes(path[0])){
      bestScore=finalScore; bestMove=path[0]; bestPath=path;
    }
  }
  debugPaths.forEach(p=>p.isChosen=(p.path===bestPath));
  if(!bestMove && trainingEnabled){
    const fallback=safeFallbackMove();
    if(fallback){if(!tempLearning[stateKey]) tempLearning[stateKey]=[]; tempLearning[stateKey].push(fallback);}
  }
  return bestMove||safeFallbackMove();
}

function getStateKey(){return `${snake[0].x},${snake[0].y}|${apples.map(a=>`${a.x},${a.y}`).join('|')}|${snake.length}`;}
function autoRetry(){ if(trainingEnabled) setTimeout(initGame,0); }

// --- Continue with Tick, Draw, Training, Learning, Init... ---
// ----- Tick -----
function tick(){
  if(paused) return;

  dir=chooseAIMove();
  const dxy=DIRS[dir], nx=snake[0].x+dxy[0], ny=snake[0].y+dxy[1];
  const newHead={x:nx,y:ny};
  let ate=false, ateYellow=false;

  for(let i=0;i<apples.length;i++){
    if(apples[i].x===nx && apples[i].y===ny){
      if(apples[i].type==='yellow'){ score+=5; ateYellow=true; }
      else{ score++; }
      scoreEl.textContent=score;
      apples.splice(i,1); spawnApple();
      eatSound.play();
      ate=true;
      break;
    }
  }

  if(nx<0||nx>=gridSize||ny<0||ny>=gridSize||collidesWithSnake(nx,ny)){
    if(lastTick){ clearInterval(lastTick); lastTick=null; }
    overlayText.textContent=`You Died! Score: ${score}`;
    overlay.style.display='flex';
    gameOverSound.play();
    gamesPlayed++; avgScore=(avgScore*(gamesPlayed-1)+score)/gamesPlayed;
    avgScoreEl.textContent=avgScore.toFixed(2);
    autoRetry();
    return;
  }

  snake.unshift(newHead);
  if(!ate) snake.pop();

  if(snake.length>=gridSize*gridSize){
    if(lastTick){ clearInterval(lastTick); lastTick=null; }
    overlayText.textContent='You Won!';
    overlay.style.display='flex';
    gamesPlayed++; avgScore=(avgScore*(gamesPlayed-1)+score)/gamesPlayed;
    avgScoreEl.textContent=avgScore.toFixed(2);
    autoRetry();
    return;
  }

  if(!trainingEnabled || tickCount % 10 === 0) drawEverything(); // skip frames during training
}

// ----- Draw -----
function drawEverything(){
  ctx.fillStyle='#111'; ctx.fillRect(0,0,canvas.width,canvas.height);

  debugPaths.forEach(dp=>{
    let x=snake[0].x, y=snake[0].y;
    dp.path.forEach(mv=>{
      const dxy=DIRS[mv]; x+=dxy[0]; y+=dxy[1];
      ctx.fillStyle=dp.isChosen?'rgba(0,255,0,0.25)':'rgba(46,196,255,0.18)';
      ctx.fillRect(x*box,y*box,box,box);
    });
  });

  apples.forEach(a=>{
    if(a.type==='yellow'){ ctx.fillStyle='#ffff00'; ctx.strokeStyle='#aaaa00'; }
    else { ctx.fillStyle='#ff4d4d'; ctx.strokeStyle='#8b0000'; }
    ctx.fillRect(a.x*box,a.y*box,box,box);
    ctx.strokeRect(a.x*box+1,a.y*box+1,box-2,box-2);
  });

  for(let i=snake.length-1;i>=0;i--){
    const s=snake[i];
    ctx.fillStyle=(i===0)?'#0077ff':'#8fcfff';
    ctx.fillRect(s.x*box,s.y*box,box,box);
    ctx.strokeStyle='#003f66'; ctx.strokeRect(s.x*box+1,s.y*box+1,box-2,box-2);
  }

  if(calcPanel.style.display!=='none'){
    calcPanel.textContent='';
    debugScores.forEach(dp=>{
      calcPanel.textContent+=`Apple(${dp.apple.x},${dp.apple.y}): [${dp.path.join(',')}] => Scores: [${dp.pathScores.map(s=>s.toFixed(0)).join(', ')}]\n`;
    });
  }
}

// ----- Training -----
trainBtn.addEventListener('click',()=>{
  trainingEnabled=!trainingEnabled;
  trainBtn.classList.toggle('active', trainingEnabled);
  if(trainingEnabled){
    initGame();
    trainingLoopChunk(20);
  } else {
    saveLearningData();
  }
});

function trainingLoopChunk(maxTicks=20){
  let ticks=0;
  while(ticks<maxTicks && trainingEnabled){
    tick();
    tickCount++;
    ticks++;
  }
  if(trainingEnabled) requestAnimationFrame(()=>trainingLoopChunk(maxTicks));
}

// ----- Learning Data Cloud -----
// ----- Learning Data Cloud via Supabase -----
async function saveLearningData(){
  if(Object.keys(tempLearning).length === 0) return;
  try {
    const { data, error } = await supabase
      .from('snake_learning')
      .insert([{ json: tempLearning }]);
    if(error) console.error('Supabase insert error:', error);
    else Object.assign(learningData, tempLearning);
    tempLearning = {};
  } catch(e){ console.error(e); }
}

async function loadLearningData(){
  try {
    const { data, error } = await supabase
      .from('snake_learning')
      .select('json')
      .order('id', { ascending: false })
      .limit(1);
    if(data && data.length > 0) learningData = data[0].json;
    if(error) console.error('Supabase load error:', error);
  } catch(e){ console.error(e); }
}


// ----- Controls -----
document.addEventListener('keydown',e=>{
  if(e.key==='ArrowUp' && dir!=='DOWN') dir='UP';
  if(e.key==='ArrowDown' && dir!=='UP') dir='DOWN';
  if(e.key==='ArrowLeft' && dir!=='RIGHT') dir='LEFT';
  if(e.key==='ArrowRight' && dir!=='LEFT') dir='RIGHT';
});
playAgainBtn.addEventListener('click',()=>initGame());
overlayBtn.addEventListener('click',()=>initGame());
speedRange.addEventListener('input',()=>{
  intervalMs=parseInt(speedRange.value);
  speedVal.textContent=intervalMs+'ms';
});
pauseBtn.addEventListener('click',()=>paused=!paused);
toggleCalcBtn.addEventListener('click',()=>{calcPanel.style.display=calcPanel.style.display==='none'?'block':'none'; drawEverything();});

async function initGame() {
  console.log("Initializing game...");
  await loadLearningData();
  setupCanvas();
  
  console.log("Grid size:", gridSize);

  snake = [
    { x: Math.floor(gridSize/2)-1, y: Math.floor(gridSize/2) },
    { x: Math.floor(gridSize/2), y: Math.floor(gridSize/2) }
  ];
  
  console.log("Snake initialized:", snake);

  apples = [];
  score = 0;
  dir = 'RIGHT';
  tickCount = 0;

  scoreEl.textContent = score;
  overlay.style.display = 'none';

  while(apples.length < appleCount) spawnApple();
  
  drawEverything();

  if(!trainingEnabled) {
    if(lastTick) clearInterval(lastTick);
    lastTick = setInterval(()=>{ if(!paused) tick(); }, intervalMs);
  }
}

// Initialize game on page load
initGame();
</script>
</body>
</html>
