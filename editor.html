<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Blue Snake Ai</title>
<style>
  :root {--bg:#111;--panel:#222;--accent:#00aaff;}
  body {margin:0;font-family:Arial,Helvetica,sans-serif;background:var(--panel);color:#fff;display:flex;flex-direction:column;align-items:center;padding:18px;}
  h1 {margin:6px 0 14px 0;}
  .controls {display:flex;flex-wrap:wrap;gap:10px;align-items:center;justify-content:center;}
  label {font-size:14px;}
  input[type="number"] {width:60px;padding:4px;border-radius:4px;border:none;text-align:center;}
  input[type="range"] {width:180px;}
  button {background:var(--accent);color:#04111a;border:none;padding:8px 12px;border-radius:6px;cursor:pointer;}
  button:hover {opacity:.95;}
  #gameArea {position:relative;margin-top:12px;}
  canvas {background:var(--bg);border:3px solid var(--accent);border-radius:8px;display:block;}
  #hud {margin-top:10px;display:flex;gap:12px;align-items:center;}
  #overlay {position:absolute;left:0;top:0;width:100%;height:100%;background:rgba(0,0,0,0.75);display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:5;display:none;}
  #overlayText {font-size:36px;margin-bottom:12px;}
  .modePicker {margin-left:6px;}
</style>
</head>
<body>
<h1>Blue Snake Ai</h1>

<div class="controls">
  <label>Map size: <input id="mapSize" type="number" min="5" max="50" value="15"></label>
  <label>Apples: <input id="appleCount" type="number" min="1" max="20" value="5"></label>
  <label>Mode:
    <select id="aiMode" class="modePicker">
      <option value="safe">Safe</option>
      <option value="greedy">Greedy</option>
    </select>
  </label>
  <label>Speed: <input id="speed" type="range" min="30" max="300" value="120"> <span id="speedVal">120ms</span></label>
  <button id="playAgain">Play Again</button>
  <button id="pauseBtn">Pause</button>
  <button id="trainBtn">Train</button>
  <button id="editorBtn">Toggle Editor</button>
</div>

<div id="gameArea">
  <canvas id="canvas"></canvas>
  <div id="overlay"><div id="overlayText"></div><button id="overlayBtn">Play Again</button></div>
</div>

<div id="hud">
  <div>Score: <span id="score">0</span></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/lz-string@1.4.4/libs/lz-string.min.js"></script>
<script>
// ----- Elements -----
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const mapSizeInput = document.getElementById('mapSize');
const appleInput = document.getElementById('appleCount');
const aiModeSelect = document.getElementById('aiMode');
const playAgainBtn = document.getElementById('playAgain');
const overlay = document.getElementById('overlay');
const overlayText = document.getElementById('overlayText');
const overlayBtn = document.getElementById('overlayBtn');
const scoreEl = document.getElementById('score');
const speedRange = document.getElementById('speed');
const speedVal = document.getElementById('speedVal');
const pauseBtn = document.getElementById('pauseBtn');
const trainBtn = document.getElementById('trainBtn');
const editorBtn = document.getElementById('editorBtn');

// ----- Sounds -----
const SND_EAT = new Audio('/sound/eated.mp3');
const SND_DEAD = new Audio('/sound/gameover.mp3');

// ----- Config -----
let box = 32;
let gridSize, appleCount, snake, apples, dir, gameTimer, intervalMs, score;
let paused = false;
let editorEnabled = false;
const DIRS = {UP:[0,-1], DOWN:[0,1], LEFT:[-1,0], RIGHT:[1,0]};
let trainingEnabled = false;
let trainingSpeed = 0.1; // milliseconds per tick

// ----- Cookie helpers -----
function getCookie(name){
  const v = document.cookie.match('(^|;)\\s*'+name+'\\s*=\\s*([^;]+)');
  return v ? JSON.parse(LZString.decompressFromBase64(decodeURIComponent(v[2]))) : {};
}
function setCookie(name, value){
  const compressed = LZString.compressToBase64(JSON.stringify(value));
  document.cookie = `${name}=${encodeURIComponent(compressed)}; path=/; max-age=${60*60*24*365}`;
}

// ----- Load learning data -----
let learningData = getCookie('snakeLearning');

// ----- Utils -----
function keyOf(x,y){ return `${x},${y}`; }
function collidesWithSnake(x,y){ return snake.some(s=>s.x===x && s.y===y); }
function getStateKey(){
  const head = snake[0];
  const appleKey = apples.map(a=>`${a.x},${a.y}`).join('|');
  return `${head.x},${head.y}|${appleKey}|${snake.length}`;
}

// ----- Canvas -----
function setupCanvas(){
  gridSize = Math.max(5, Math.min(50, parseInt(mapSizeInput.value)||15));
  appleCount = Math.max(1, Math.min(20, parseInt(appleInput.value)||5));
  box = Math.max(12, Math.floor(640/gridSize));
  canvas.width = canvas.height = box*gridSize;
}

// ----- Spawn apple -----
function spawnApple(){
  let attempts=0;
  while(attempts<2000){
    const x=Math.floor(Math.random()*gridSize), y=Math.floor(Math.random()*gridSize);
    if(!collidesWithSnake(x,y) && !apples.some(a=>a.x===x&&a.y===y)){
      apples.push({x,y});
      return;
    }
    attempts++;
  }
}

// ----- Flood fill -----
function floodFillCount(sx,sy,snakeBody,limit=1000){
  const visited = new Set(), bodySet = new Set(snakeBody.map(s=>keyOf(s.x,s.y)));
  const q=[{x:sx,y:sy}]; let cnt=0;
  while(q.length && cnt<limit){
    const p=q.shift(); const k=keyOf(p.x,p.y);
    if(visited.has(k)) continue;
    if(p.x<0||p.x>=gridSize||p.y<0||p.y>=gridSize) continue;
    if(bodySet.has(k)) continue;
    visited.add(k); cnt++;
    q.push({x:p.x+1,y:p.y}); q.push({x:p.x-1,y:p.y});
    q.push({x:p.x,y:p.y+1}); q.push({x:p.x,y:p.y-1});
  }
  return cnt;
}

// ----- A* -----
function aStarPath(start,target,snakeBody){
  const bodySet=new Set(snakeBody.map(s=>keyOf(s.x,s.y)));
  const h=(x,y)=>Math.abs(x-target.x)+Math.abs(y-target.y);
  const open=new Map(); const closed=new Set();
  const startK=keyOf(start.x,start.y);
  open.set(startK,{x:start.x,y:start.y,g:0,f:h(start.x,start.y),parent:null,move:null});
  while(open.size){
    let current, currentK;
    for(const [k,n] of open){ if(!current || n.f<current.f){ current=n; currentK=k; } }
    open.delete(currentK); closed.add(currentK);
    if(current.x===target.x && current.y===target.y){
      const out=[]; let node=current;
      while(node.parent){ out.unshift(node.move); node=node.parent; }
      return out;
    }
    for(const [dx,dy,name] of [[0,-1,'UP'],[0,1,'DOWN'],[-1,0,'LEFT'],[1,0,'RIGHT']]){
      const nx=current.x+dx, ny=current.y+dy, nk=keyOf(nx,ny);
      if(nx<0||nx>=gridSize||ny<0||ny>=gridSize) continue;
      if(closed.has(nk)) continue;
      if(bodySet.has(nk) && !(nx===target.x&&ny===target.y)) continue;
      const ng=current.g+1;
      if(!open.has(nk) || ng<open.get(nk).g){
        open.set(nk,{x:nx,y:ny,g:ng,f:ng+h(nx,ny),parent:current,move:name});
      }
    }
  }
  return [];
}

// ----- AI Move with Path Visualization -----
let debugPaths = [];
function chooseAIMove(){
  debugPaths = [];
  const stateKey = getStateKey();
  const forbiddenMoves = learningData[stateKey] || [];
  const start={x:snake[0].x,y:snake[0].y};
  const mode=aiModeSelect.value;
  let bestScore=-Infinity, bestMove=null;
  let bestPath = [];

  for(const apple of apples){
    const path=aStarPath(start,apple,snake);
    if(!path.length) continue;
    debugPaths.push({path, apple});
    let simSnake=snake.map(s=>({x:s.x,y:s.y})), simHead={x:simSnake[0].x,y:simSnake[0].y};
    path.forEach((mv,i)=>{
      if(i>50) return;
      const dxy=DIRS[mv];
      simHead={x:simHead.x+dxy[0],y:simHead.y+dxy[1]};
      simSnake.unshift({...simHead});
      simSnake.pop();
    });
    const free=floodFillCount(simHead.x,simHead.y,simSnake,2000);
    let scoreVal=(mode==='greedy'?1000-free:free);
    if(scoreVal>bestScore && !forbiddenMoves.includes(path[0])){
      bestScore=scoreVal; bestMove=path[0]; bestPath = path;
    }
  }
  debugPaths.forEach(p=>p.isChosen = (p.path === bestPath));
  if(!bestMove && trainingEnabled){
    if(!learningData[stateKey]) learningData[stateKey]=[];
    learningData[stateKey].push(dir);
    setCookie('snakeLearning', learningData);
  }
  return bestMove || safeFallbackMove();
}
function safeFallbackMove(){ for(const mv of ['UP','RIGHT','DOWN','LEFT']) if(isMoveSafe(mv)) return mv; return dir; }
function isMoveSafe(mv){ const dxy=DIRS[mv]; const nx=snake[0].x+dxy[0], ny=snake[0].y+dxy[1]; return nx>=0 && nx<gridSize && ny>=0 && ny<gridSize && !collidesWithSnake(nx,ny); }

// ----- Tick -----
function tick(){
  if(paused) return;
  dir = chooseAIMove();

  const dxy=DIRS[dir]; const nx=snake[0].x+dxy[0], ny=snake[0].y+dxy[1]; const newHead={x:nx,y:ny};
  if(nx<0||nx>=gridSize||ny<0||ny>=gridSize||collidesWithSnake(nx,ny)){
    clearInterval(gameTimer);
    if(!trainingEnabled) SND_DEAD.play().catch(()=>{});
    overlayText.textContent=`You Died! Score: ${score}`; overlay.style.display='flex';
    if(trainingEnabled) autoRetry();
    return;
  }

  let ate=false;
  for(let i=0;i<apples.length;i++){
    if(apples[i].x===nx && apples[i].y===ny){
      ate=true; score++; scoreEl.textContent=score;
      if(!trainingEnabled) SND_EAT.play().catch(()=>{});
      apples.splice(i,1); spawnApple(); break;
    }
  }

  snake.unshift(newHead); if(!ate) snake.pop();
  if(snake.length>=gridSize*gridSize){ clearInterval(gameTimer); overlayText.textContent='You Won!'; overlay.style.display='flex'; if(trainingEnabled) autoRetry(); return; }
  drawEverything();
}

// ----- Draw -----
function drawEverything(){
  ctx.fillStyle='#111'; ctx.fillRect(0,0,canvas.width,canvas.height);

  // draw paths
  debugPaths.forEach(dp=>{
    let x=snake[0].x, y=snake[0].y;
    for(let i=0;i<dp.path.length;i++){
      const mv = dp.path[i];
      const dxy=DIRS[mv];
      x+=dxy[0]; y+=dxy[1];
      ctx.fillStyle = dp.isChosen ? 'rgba(0,255,0,0.7)' : 'rgba(255,255,0,0.2)';
      ctx.fillRect(x*box, y*box, box, box);
    }
  });

  // apples
  for(const a of apples){ const px=a.x*box, py=a.y*box; ctx.fillStyle='#ff4d4d'; ctx.fillRect(px,py,box,box); ctx.strokeStyle='#8b0000'; ctx.strokeRect(px+1,py+1,box-2,box-2);}
  
  // snake
  for(let i=snake.length-1;i>=0;i--){ const s=snake[i]; const px=s.x*box, py=s.y*box; ctx.fillStyle=(i===0)?'#0077ff':'#8fcfff'; ctx.fillRect(px,py,box,box); ctx.strokeStyle='#003f66'; ctx.strokeRect(px+1,py+1,box-2,box-2);}
  
  // editor overlay
  if(editorEnabled){
    ctx.fillStyle='rgba(255,255,255,0.1)';
    ctx.fillRect(0,0,canvas.width,canvas.height);
  }
}

// ----- Editor -----
canvas.addEventListener('click',(e)=>{
  if(!editorEnabled) return;
  const rect = canvas.getBoundingClientRect();
  const x = Math.floor((e.clientX-rect.left)/box);
  const y = Math.floor((e.clientY-rect.top)/box);
  
  // toggle wall / apple
  const wallKey = keyOf(x,y);
  let appleIndex = apples.findIndex(a=>a.x===x&&a.y===y);
  if(appleIndex>=0){ apples.splice(appleIndex,1); }
  else{ apples.push({x,y}); }
});
editorBtn.addEventListener('click',()=>editorEnabled=!editorEnabled);

// ----- Auto retry -----
function autoRetry(){
  if(trainingEnabled){
    initGame(); intervalMs=trainingSpeed; clearInterval(gameTimer); gameTimer=setInterval(tick,intervalMs);
  }
}

// ----- Controls -----
document.addEventListener('keydown',(e)=>{
  if(e.key==='ArrowUp' && dir!=='DOWN') dir='UP';
  if(e.key==='ArrowDown' && dir!=='UP') dir='DOWN';
  if(e.key==='ArrowLeft' && dir!=='RIGHT') dir='LEFT';
  if(e.key==='ArrowRight' && dir!=='LEFT') dir='RIGHT';
});
playAgainBtn.addEventListener('click',()=>initGame());
overlayBtn.addEventListener('click',()=>initGame());
speedRange.addEventListener('input',()=>setSpeed(parseInt(speedRange.value)));
pauseBtn.addEventListener('click',()=>paused=!paused);
trainBtn.addEventListener('click',()=>{ trainingEnabled=!trainingEnabled; if(trainingEnabled) autoRetry(); });

// ----- Speed -----
function setSpeed(ms){ intervalMs=ms; speedVal.textContent=ms+'ms'; if(gameTimer){ clearInterval(gameTimer); gameTimer=setInterval(tick,intervalMs); }}

// ----- Init -----
function initGame(){
  setupCanvas();
  snake=[{x:Math.floor(gridSize/2),y:Math.floor(gridSize/2)}];
  apples=[]; score=0; dir='RIGHT'; paused=false;
  scoreEl.textContent=score; overlay.style.display='none';
  while(apples.length<appleCount) spawnApple();
  setSpeed(trainingEnabled?trainingSpeed:parseInt(speedRange.value));
  if(gameTimer) clearInterval(gameTimer);
  gameTimer=setInterval(tick,intervalMs);
}

initGame();
</script>
</body>
</html>
