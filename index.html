<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Blue Snake AI</title>
<style>
  :root{--bg:#111;--panel:#222;--accent:#00aaff;}
  body{margin:0;font-family:Arial,Helvetica,sans-serif;background:var(--panel);color:#fff;display:flex;flex-direction:column;align-items:center;padding:18px;}
  h1{margin:6px 0 14px 0}
  .controls{display:flex;flex-wrap:wrap;gap:10px;align-items:center;justify-content:center}
  label{font-size:14px}
  input[type="number"]{width:64px;padding:4px;border-radius:4px;border:none;text-align:center}
  input[type="range"]{width:200px}
  select{padding:4px;border-radius:4px;border:none}
  button{background:var(--accent);color:#04111a;border:none;padding:8px 12px;border-radius:6px;cursor:pointer}
  button:hover{opacity:.95}
  #gameArea{position:relative;margin-top:12px}
  canvas{background:var(--bg);border:3px solid var(--accent);border-radius:8px;display:block}
  #hud{margin-top:10px;display:flex;gap:12px;align-items:center}
  #scoreDisplay{font-weight:700}
  #overlay{position:absolute;left:0;top:0;width:100%;height:100%;background:rgba(0,0,0,0.75);display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:5;display:none}
  #overlayText{font-size:48px;margin-bottom:12px}
</style>
</head>
<body>
<h1>Blue Snake AI</h1>

<div class="controls">
  <label>Map size: <input id="mapSize" type="number" min="5" max="50" value="15"></label>
  <label>Apples: <input id="appleCount" type="number" min="1" max="20" value="5"></label>
  <label><input id="useAI" type="checkbox" checked> Use AI</label>
  <label>AI Mode: <select id="aiMode">
    <option value="safe">Safe</option>
    <option value="greedy">Greedy</option>
  </select></label>
  <label><input id="showPath" type="checkbox"> Show paths</label>
  <label>Speed: <input id="speed" type="range" min="30" max="300" value="120"> <span id="speedVal">120ms</span></label>
  <button id="playAgain">Play Again</button>
</div>

<div id="gameArea">
  <canvas id="canvas"></canvas>
  <div id="overlay"><div id="overlayText"></div><button id="overlayBtn">Play Again</button><div id="finalScore"></div></div>
</div>

<div id="hud">
  <div>Score: <span id="scoreDisplay">0</span></div>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const mapSizeInput = document.getElementById('mapSize');
const appleInput = document.getElementById('appleCount');
const useAICheck = document.getElementById('useAI');
const aiModeSelect = document.getElementById('aiMode');
const showPathCheck = document.getElementById('showPath');
const playAgainBtn = document.getElementById('playAgain');
const overlay = document.getElementById('overlay');
const overlayText = document.getElementById('overlayText');
const overlayBtn = document.getElementById('overlayBtn');
const finalScore = document.getElementById('finalScore');
const scoreEl = document.getElementById('scoreDisplay');
const speedRange = document.getElementById('speed');
const speedVal = document.getElementById('speedVal');

const SND_EAT = new Audio('/sound/eated.mp3');
const SND_DEAD = new Audio('/sound/gameover.mp3');

let box = 32;
let gridSize, appleCount, snake, apples, dir, gameTimer, intervalMs, score;
const DIRS = { UP:[0,-1],'DOWN':[0,1],'LEFT':[-1,0],'RIGHT':[1,0] };
let lastAlgPaths = [];

// ---------------- Utilities ----------------
function keyOf(x,y){ return `${x},${y}`; }

// ---------------- Resize canvas ----------------
function setupCanvas(){
  gridSize = Math.max(5, Math.min(50, parseInt(mapSizeInput.value)||15));
  appleCount = Math.max(1, Math.min(20, parseInt(appleInput.value)||5));
  const desired=640;
  box=Math.max(12,Math.floor(desired/gridSize));
  canvas.width=canvas.height=box*gridSize;
}

// ---------------- Spawn Apple ----------------
function spawnApple(){
  let attempts=0;
  while(attempts<2000){
    const x=Math.floor(Math.random()*gridSize);
    const y=Math.floor(Math.random()*gridSize);
    if(!snake.some(s=>s.x===x&&s.y===y)&&!apples.some(a=>a.x===x&&a.y===y)){
      apples.push({x,y});
      return;
    }
    attempts++;
  }
}

// ---------------- Collision ----------------
function collidesWithSnake(x,y){
  return snake.some(s=>s.x===x&&s.y===y);
}

// ---------------- Flood fill ----------------
function floodFillCount(sx, sy, snakeBody, limit=100000){
  const visited = new Set();
  const q=[{x:sx,y:sy}];
  const bodySet = new Set(snakeBody.map(s=>keyOf(s.x,s.y)));
  let cnt=0;
  while(q.length && cnt<limit){
    const p=q.shift();
    const k=keyOf(p.x,p.y);
    if(visited.has(k)) continue;
    if(p.x<0||p.x>=gridSize||p.y<0||p.y>=gridSize) continue;
    if(bodySet.has(k)) continue;
    visited.add(k); cnt++;
    q.push({x:p.x+1,y:p.y});q.push({x:p.x-1,y:p.y});q.push({x:p.x,y:p.y+1});q.push({x:p.x,y:p.y-1});
  }
  return cnt;
}

// ---------------- BFS ----------------
function bfsPath(start,target,snakeBody){
  const startK=keyOf(start.x,start.y);
  const bodySet=new Set(snakeBody.map(s=>keyOf(s.x,s.y)));
  const q=[{x:start.x,y:start.y,path:[]}];
  const visited=new Set([startK]);
  while(q.length){
    const node=q.shift();
    if(node.x===target.x && node.y===target.y) return node.path;
    for(const [dx,dy,name] of [[0,-1,'UP'],[0,1,'DOWN'],[-1,0,'LEFT'],[1,0,'RIGHT']]){
      const nx=node.x+dx, ny=node.y+dy, k=keyOf(nx,ny);
      if(nx<0||nx>=gridSize||ny<0||ny>=gridSize) continue;
      if(visited.has(k)) continue;
      if(bodySet.has(k)&&!(nx===target.x&&ny===target.y)) continue;
      visited.add(k);
      q.push({x:nx,y:ny,path:node.path.concat(name)});
    }
  }
  return [];
}

// ---------------- A* ----------------
function aStarPath(start,target,snakeBody){
  const bodySet = new Set(snakeBody.map(s=>keyOf(s.x,s.y)));
  function h(x,y){return Math.abs(x-target.x)+Math.abs(y-target.y);}
  const open=new Map();
  const closed=new Set();
  const startK=keyOf(start.x,start.y);
  open.set(startK,{x:start.x,y:start.y,g:0,f:h(start.x,start.y),parent:null,move:null});
  while(open.size){
    let currentK,current;
    for(const [k,n] of open){if(!current||n.f<current.f){current=n;currentK=k;}}
    open.delete(currentK);
    if(current.x===target.x&&current.y===target.y){
      const out=[];
      let node=current;
      while(node.parent){out.unshift(node.move);node=node.parent;}
      return out;
    }
    closed.add(currentK);
    for(const [dx,dy,name] of [[0,-1,'UP'],[0,1,'DOWN'],[-1,0,'LEFT'],[1,0,'RIGHT']]){
      const nx=current.x+dx,ny=current.y+dy,nk=keyOf(nx,ny);
      if(nx<0||nx>=gridSize||ny<0||ny>=gridSize) continue;
      if(closed.has(nk)) continue;
      if(bodySet.has(nk)&&!(nx===target.x&&ny===target.y)) continue;
      const ng=current.g+1;
      if(!open.has(nk)||ng<open.get(nk).g) open.set(nk,{x:nx,y:ny,g:ng,f:ng+h(nx,ny),parent:current,move:name});
    }
  }
  return [];
}

// ---------------- Choose AI move ----------------
function chooseAIMove(){
  if(!useAICheck.checked) return dir;
  const mode = aiModeSelect.value; // "safe" or "greedy"
  let bestMove=null;
  let bestScore=-Infinity;
  let start={x:snake[0].x,y:snake[0].y};
  lastAlgPaths=[];
  let candidates = [];
  for(const apple of apples){
    const pathA=aStarPath(start,apple,snake);
    const pathB=bfsPath(start,apple,snake);
    if(pathA.length||pathB.length) candidates.push({apple,pathA,pathB});
    lastAlgPaths.push({apple,pathA,pathB});
  }
  if(candidates.length===0) return safeFallbackMove();
  for(const c of candidates){
    let chosenPath=(mode==='greedy') ? (c.pathA.length?c.pathA:c.pathB) : (c.pathA.length?c.pathA:c.pathB);
    if(!chosenPath||chosenPath.length===0) continue;
    let simSnake=snake.map(s=>({x:s.x,y:s.y}));
    let simHead={x:simSnake[0].x,y:simSnake[0].y};
    for(const mv of chosenPath){
      const dxy=DIRS[mv];
      simHead={x:simHead.x+dxy[0],y:simHead.y+dxy[1]};
      simSnake.unshift({x:simHead.x,y:simHead.y}); simSnake.pop();
    }
    const free=floodFillCount(simHead.x,simHead.y,simSnake,2000);
    const score=(mode==='safe')?free:-chosenPath.length;
    if(score>bestScore){bestScore=score;bestMove=chosenPath[0];}
  }
  return bestMove||safeFallbackMove();
}

function safeFallbackMove(){
  for(const mv of ['UP','RIGHT','DOWN','LEFT']) if(isMoveSafe(mv)) return mv;
  return dir;
}
function isMoveSafe(mv){
  const dxy=DIRS[mv];
  const nx=snake[0].x+dxy[0],ny=snake[0].y+dxy[1];
  if(nx<0||nx>=gridSize||ny<0||ny>=gridSize) return false;
  if(collidesWithSnake(nx,ny)) return false;
  return true;
}

// ---------------- Tick ----------------
function tick(){
  if(useAICheck.checked) dir=chooseAIMove();
  const dxy=DIRS[dir]; const nx=snake[0].x+dxy[0],ny=snake[0].y+dxy[1];
  const newHead={x:nx,y:ny};
  if(nx<0||nx>=gridSize||ny<0||ny>=gridSize||collidesWithSnake(nx,ny)){
    clearInterval(gameTimer); SND_DEAD.play().catch(()=>{});
    overlayText.textContent='You Died!';
    finalScore.textContent='Score: '+score;
    overlay.style.display='flex'; return;
  }
  let ate=false;
  for(let i=0;i<apples.length;i++){if(apples[i].x===nx&&apples[i].y===ny){ate=true;score++;scoreEl.textContent=score;SND_EAT.play().catch(()=>{});apples.splice(i,1);spawnApple();break;}}
  snake.unshift(newHead); if(!ate) snake.pop();
  if(snake.length>=gridSize*gridSize){clearInterval(gameTimer);overlayText.textContent='You Won!';overlay.style.display='flex';return;}
  drawEverything();
}

// ---------------- Draw ----------------
function drawEverything(){
  ctx.fillStyle='#111';ctx.fillRect(0,0,canvas.width,canvas.height);
  if(showPathCheck.checked && lastAlgPaths.length){
    for(const pinfo of lastAlgPaths){
      if(pinfo.pathA && pinfo.pathA.length) drawPath(pinfo.pathA,'#2ec4ff',0.35);
      if(pinfo.pathB && pinfo.pathB.length) drawPath(pinfo.pathB,'#00ffcc',0.28);
    }
  }
  for(const a of apples){ctx.fillStyle='#ff4d4d';ctx.fillRect(a.x*box,a.y*box,box,box);ctx.strokeStyle='#8b0000';ctx.strokeRect(a.x*box+1,a.y*box+1,box-2,box-2);}
  for(let i=snake.length-1;i>=0;i--){const s=snake[i];ctx.fillStyle=(i===0)?'#0077ff':'#8fcfff';ctx.fillRect(s.x*box,s.y*box,box,box);ctx.strokeStyle='#003f66';ctx.strokeRect(s.x*box+1,s.y*box+1,box-2,box-2);}
}
function drawPath(path,color,alpha=0.3){ctx.save();ctx.globalAlpha=alpha;ctx.fillStyle=color;let pos={x:snake[0].x,y:snake[0].y};for(const mv of path){pos={x:pos.x+DIRS[mv][0],y:pos.y+DIRS[mv][1]};ctx.fillRect(pos.x*box+box*0.25,pos.y*box+box*0.25,box*0.5,box*0.5);}ctx.restore();}

// ---------------- Manual controls ----------------
document.addEventListener('keydown',(e)=>{
  if(useAICheck.checked) return;
  if(e.key==='ArrowUp'&&dir!=='DOWN') dir='UP';
  if(e.key==='ArrowDown'&&dir!=='UP') dir='DOWN';
  if(e.key==='ArrowLeft'&&dir!=='RIGHT') dir='LEFT';
  if(e.key==='ArrowRight'&&dir!=='LEFT') dir='RIGHT';
});

// ---------------- UI ----------------
function initGame(){
  setupCanvas(); snake=[{x:Math.floor(gridSize/2),y:Math.floor(gridSize/2)}];apples=[];score=0;dir='RIGHT';scoreEl.textContent=score;overlay.style.display='none';
  while(apples.length<appleCount) spawnApple();
  setSpeed(parseInt(speedRange.value));
  if(gameTimer) clearInterval(gameTimer);
  gameTimer=setInterval(tick,intervalMs);
}
function setSpeed(ms){intervalMs=ms;speedVal.textContent=ms+'ms';if(gameTimer){clearInterval(gameTimer);gameTimer=setInterval(tick,intervalMs);}}
playAgainBtn.addEventListener('click',()=>initGame());
overlayBtn.addEventListener('click',()=>initGame());
speedRange.addEventListener('input',()=>setSpeed(parseInt(speedRange.value)));
mapSizeInput.addEventListener('change',()=>initGame());
appleInput.addEventListener('change',()=>initGame());
useAICheck.addEventListener('change',()=>{});
showPathCheck.addEventListener('change',()=>{});

// ---------------- Start ----------------
initGame();
</script>
</body>
</html>
