<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Blue Snake AI - Future Lookahead</title>
<style>
body { display:flex; flex-direction:column; align-items:center; background:#222; font-family:Arial; color:#fff; margin:0; padding:20px;}
canvas { background:#111; border:3px solid #00f; border-radius:8px; margin:20px 0;}
h1 { margin:10px 0;}
label, button, input { margin:10px; font-size:1.2em;}
button { padding:8px 16px; cursor:pointer; background:#00f; color:#fff; border:none; border-radius:5px;}
button:hover { background:#0055ff;}
input[type=number]{width:60px; padding:2px;}
</style>
</head>
<body>
<h1>Blue Snake AI - Infinite Lookahead</h1>
<label><input type="checkbox" id="useAI"> Use AI</label>
<label><input type="checkbox" id="showPath"> Show AI Path</label>
<label>Map Size: <input type="number" id="mapSize" value="20" min="10" max="100"></label>
<label>Food Count: <input type="number" id="foodCount" value="5" min="1" max="50"></label>
<canvas id="snake" width="640" height="640"></canvas>
<h1>Score: <span id="score">0</span></h1>
<button id="playAgain">Play Again</button>

<script>
const cvs = document.getElementById("snake");
const ctx = cvs.getContext("2d");
let box = 32;
let gridSize = parseInt(document.getElementById("mapSize").value);
let foodCount = parseInt(document.getElementById("foodCount").value);

let snake, foods, score, d, game;
const useAI = document.getElementById("useAI");
const showPath = document.getElementById("showPath");

const dead = new Audio("/sound/gameover.mp3");
const eat = new Audio("/sound/eated.mp3");

// ---------------- Initialize Game ----------------
function initGame() {
    box = Math.floor(600/gridSize);
    cvs.width = cvs.height = box*gridSize;

    snake = [{x: Math.floor(gridSize/2)*box, y: Math.floor(gridSize/2)*box}];
    foods = spawnFoods(foodCount);
    score = 0;
    d = "RIGHT";
    if(game) clearInterval(game);
    game = setInterval(draw, 100);
}

// ---------------- Spawn Foods ----------------
function spawnFoods(count){
    let arr=[];
    while(arr.length<count){
        let f = {x: Math.floor(Math.random()*gridSize)*box, y: Math.floor(Math.random()*gridSize)*box};
        if(!snake.some(seg=>seg.x===f.x && seg.y===f.y) && !arr.some(fd=>fd.x===f.x && fd.y===f.y))
            arr.push(f);
    }
    return arr;
}

// ---------------- Collision ----------------
function collision(head, array){
    return array.some(seg => seg.x===head.x && seg.y===head.y);
}

// ---------------- AI Recursive Lookahead ----------------
function simulateSnake(testSnake, testFoods, depth){
    if(depth===0 || testFoods.length===0) return {score:0, path:[]};

    const moves = ["UP","DOWN","LEFT","RIGHT"];
    let best = {score:-Infinity, path:[]};

    for(let move of moves){
        let head = {...testSnake[0]};
        if(move==="UP") head.y-=box;
        if(move==="DOWN") head.y+=box;
        if(move==="LEFT") head.x-=box;
        if(move==="RIGHT") head.x+=box;

        if(head.x<0 || head.x>=gridSize*box || head.y<0 || head.y>=gridSize*box) continue;
        if(testSnake.some(seg=>seg.x===head.x && seg.y===head.y)) continue;

        let newSnake = [head, ...testSnake];
        let newFoods = testFoods.map(f=>({...f}));
        let gained=0;

        for(let i=0;i<newFoods.length;i++){
            if(head.x===newFoods[i].x && head.y===newFoods[i].y){
                newFoods.splice(i,1);
                gained=1;
                break;
            }
        }
        if(gained===0) newSnake.pop();

        let {score:s, path:p} = simulateSnake(newSnake,newFoods,depth-1);
        s += gained*1000; // prioritize eating
        if(s>best.score) best={score:s, path:[move,...p]};
    }
    return best;
}

function getAIMove(){
    if(!useAI.checked) return d;
    let lookaheadDepth = 15; // increase for more future insight
    let {path} = simulateSnake(snake, foods, lookaheadDepth);
    if(showPath.checked && path.length>0){
        // Draw planned path
        let pos={...snake[0]};
        ctx.fillStyle="rgba(0,200,255,0.5)";
        for(let m of path){
            if(m==="UP") pos.y-=box;
            if(m==="DOWN") pos.y+=box;
            if(m==="LEFT") pos.x-=box;
            if(m==="RIGHT") pos.x+=box;
            ctx.fillRect(pos.x+box/4,pos.y+box/4,box/2,box/2);
        }
    }
    return path.length>0 ? path[0] : d;
}

// ---------------- Draw ----------------
function draw(){
    ctx.fillStyle="#111";
    ctx.fillRect(0,0,cvs.width,cvs.height);

    // Draw snake
    snake.forEach((seg,i)=>{
        ctx.fillStyle = i===0 ? "blue" : "lightblue";
        ctx.fillRect(seg.x,seg.y,box,box);
        ctx.strokeStyle="darkblue";
        ctx.strokeRect(seg.x,seg.y,box,box);
    });

    // Draw foods
    foods.forEach(f=>{
        ctx.fillStyle="red";
        ctx.fillRect(f.x,f.y,box,box);
    });

    // Determine next move
    d = getAIMove();

    let snakeX = snake[0].x;
    let snakeY = snake[0].y;
    if(d==="UP") snakeY-=box;
    if(d==="DOWN") snakeY+=box;
    if(d==="LEFT") snakeX-=box;
    if(d==="RIGHT") snakeX+=box;

    // Eat foods
    for(let i=0;i<foods.length;i++){
        if(snakeX===foods[i].x && snakeY===foods[i].y){
            score++;
            eat.play();
            foods.splice(i,1);
            // spawn new if total less than count
            if(foods.length<foodCount) foods.push(spawnFoods(1)[0]);
            break;
        }
    }

    let newHead={x:snakeX, y:snakeY};
    if(snakeX<0 || snakeX>=gridSize*box || snakeY<0 || snakeY>=gridSize*box || collision(newHead,snake)){
        clearInterval(game);
        dead.play();
        return;
    }

    snake.unshift(newHead);
    snake.pop();

    document.getElementById("score").textContent = score;
}

// ---------------- Play Again ----------------
document.getElementById("playAgain").addEventListener("click", ()=>{
    gridSize = parseInt(document.getElementById("mapSize").value);
    foodCount = parseInt(document.getElementById("foodCount").value);
    initGame();
});

// Start
initGame();
</script>
</body>
</html>
