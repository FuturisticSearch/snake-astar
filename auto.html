<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Blue Snake AI</title>
<style>
  :root{--bg:#111;--panel:#222;--accent:#00aaff;}
  body{margin:0;font-family:Arial,Helvetica,sans-serif;background:var(--panel);color:#fff;display:flex;flex-direction:column;align-items:center;padding:18px;}
  h1{margin:6px 0 14px 0}
  .controls{display:flex;flex-wrap:wrap;gap:10px;align-items:center;justify-content:center}
  label{font-size:14px}
  input[type="number"]{width:64px;padding:4px;border-radius:4px;border:none;text-align:center}
  input[type="range"]{width:200px}
  button{background:var(--accent);color:#04111a;border:none;padding:8px 12px;border-radius:6px;cursor:pointer}
  button:hover{opacity:.95}
  #gameArea{position:relative;margin-top:12px}
  canvas{background:var(--bg);border:3px solid var(--accent);border-radius:8px;display:block}
  #hud{margin-top:10px;display:flex;gap:12px;align-items:center}
  #score{font-weight:700}
  #overlay{position:absolute;left:0;top:0;width:100%;height:100%;background:rgba(0,0,0,0.75);display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:5;display:none}
  #overlayText{font-size:48px;margin-bottom:12px}
  .legend{display:flex;gap:8px;align-items:center;margin-left:8px}
  .sw{width:16px;height:16px;border-radius:3px;display:inline-block}
  .aStar{background:#2ec4ff} .bfs{background:#00ffcc} .dij{background:#ffd166} .chosen{outline:2px solid #fff}
  @media (max-width:640px){input[type="range"]{width:140px}}
</style>
</head>
<body>
  <h1>Blue Snake AI</h1>

  <div class="controls">
    <label>Map size: <input id="mapSize" type="number" min="5" max="100" value="15"></label>
    <label>Apples: <input id="appleCount" type="number" min="1" max="50" value="5"></label>
    <label><input id="useAI" type="checkbox"> Use AI</label>
    <label><input id="showPath" type="checkbox"> Show paths</label>
    <label>Speed: <input id="speed" type="range" min="30" max="300" value="120"> <span id="speedVal">120ms</span></label>
    <button id="playAgain">Play Again</button>
    <div class="legend">
      <span class="sw aStar"></span> A* 
      <span class="sw bfs"></span> BFS 
      <span class="sw dij"></span> Dijkstra 
      <span class="sw chosen" style="background:#fff;margin-left:6px"></span> Chosen
    </div>
  </div>

  <div id="gameArea">
    <canvas id="canvas"></canvas>
    <div id="overlay"><div id="overlayText"></div><button id="overlayBtn">Play Again</button></div>
  </div>

  <div id="hud">
    <div>Score: <span id="score">0</span></div>
  </div>

<script>
// ---------------- Config & elements ----------------
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const mapSizeInput = document.getElementById('mapSize');
const appleInput = document.getElementById('appleCount');
const useAICheck = document.getElementById('useAI');
const showPathCheck = document.getElementById('showPath');
const playAgainBtn = document.getElementById('playAgain');
const overlay = document.getElementById('overlay');
const overlayText = document.getElementById('overlayText');
const overlayBtn = document.getElementById('overlayBtn');
const scoreEl = document.getElementById('score');
const speedRange = document.getElementById('speed');
const speedVal = document.getElementById('speedVal');

const SND_EAT = new Audio('/sound/eated.mp3');
const SND_DEAD = new Audio('/sound/gameover.mp3');

// grid cell size (px)
let box = 32;
// game state
let gridSize, appleCount, snake, apples, dir, gameTimer, intervalMs, score;
// convenience
const DIRS = { UP:[0,-1],'DOWN':[0,1],'LEFT':[-1,0],'RIGHT':[1,0] };

// ---------------- Utilities ----------------
function toCell(p){ return { x: Math.round(p.x/box), y: Math.round(p.y/box) }; }
function cellToPx(cx,cy){ return { x: cx*box, y: cy*box }; }
function keyOf(cx,cy){ return `${cx},${cy}`; }

// ---------------- Resize canvas according to map ----------------
function setupCanvas(){
  gridSize = Math.max(5, Math.min(100, parseInt(mapSizeInput.value) || 15));
  appleCount = Math.max(1, Math.min(50, parseInt(appleInput.value) || 5));
  // fit canvas so box*gridSize fits nicely but keep box reasonable
  const desired = 640; // approx max playable px
  box = Math.max(12, Math.floor(desired / gridSize));
  canvas.width = canvas.height = box * gridSize;
}

// ---------------- Game init ----------------
function initGame(){
  setupCanvas();
  snake = [ { x: Math.floor(gridSize/2), y: Math.floor(gridSize/2) } ]; // cells
  apples = [];
  score = 0;
  dir = 'RIGHT';
  scoreEl.textContent = score;
  overlay.style.display = 'none';
  // spawn apples
  while(apples.length < appleCount){
    spawnApple();
  }
  // set interval speed
  setSpeed(parseInt(speedRange.value));
  // start loop
  if(gameTimer) clearInterval(gameTimer);
  gameTimer = setInterval(tick, intervalMs);
}

// ---------------- Speed setter ----------------
function setSpeed(ms){
  intervalMs = ms;
  speedVal.textContent = ms + 'ms';
  if(gameTimer){
    clearInterval(gameTimer);
    gameTimer = setInterval(tick, intervalMs);
  }
}

// ---------------- Spawn apple ----------------
function spawnApple(){
  let attempts=0;
  while(attempts < 2000){
    const cx = Math.floor(Math.random()*gridSize);
    const cy = Math.floor(Math.random()*gridSize);
    if(!snake.some(s=>s.x===cx && s.y===cy) && !apples.some(a=>a.x===cx && a.y===cy)){
      apples.push({x:cx,y:cy});
      return;
    }
    attempts++;
  }
  // fallback: fill whatever
  for(let y=0;y<gridSize;y++) for(let x=0;x<gridSize;x++){
    if(!snake.some(s=>s.x===x && s.y===y) && !apples.some(a=>a.x===x && a.y===y)){
      apples.push({x,y}); return;
    }
  }
}

// ---------------- Collision test ----------------
function collidesWithSnake(cx,cy){
  return snake.some(seg=>seg.x===cx && seg.y===cy);
}

// ---------------- Flood fill (limit optionally) ----------------
function floodFillCount(sx, sy, snakeBody, limit=100000){
  const visited = new Set();
  const q=[{x:sx,y:sy}];
  const bodySet = new Set(snakeBody.map(s=>keyOf(s.x,s.y)));
  let cnt=0;
  while(q.length && cnt < limit){
    const p=q.shift();
    const k=keyOf(p.x,p.y);
    if(visited.has(k)) continue;
    if(p.x<0||p.x>=gridSize||p.y<0||p.y>=gridSize) continue;
    if(bodySet.has(k)) continue;
    visited.add(k);
    cnt++;
    q.push({x:p.x+1,y:p.y}); q.push({x:p.x-1,y:p.y});
    q.push({x:p.x,y:p.y+1}); q.push({x:p.x,y:p.y-1});
  }
  return cnt;
}

// ---------------- BFS pathfinder ----------------
function bfsPath(start, target, snakeBody){
  const startK = keyOf(start.x,start.y);
  const bodySet = new Set(snakeBody.map(s=>keyOf(s.x,s.y)));
  const q = [ {x:start.x,y:start.y,path:[]} ];
  const visited = new Set([startK]);
  while(q.length){
    const node = q.shift();
    if(node.x===target.x && node.y===target.y) return node.path;
    for(const [dx,dy,name] of [[0,-1,'UP'],[0,1,'DOWN'],[-1,0,'LEFT'],[1,0,'RIGHT']]){
      const nx=node.x+dx, ny=node.y+dy;
      const k=keyOf(nx,ny);
      if(nx<0||nx>=gridSize||ny<0||ny>=gridSize) continue;
      if(visited.has(k)) continue;
      // treat snake body as obstacle except if target on body (allow stepping onto target)
      if(bodySet.has(k) && !(nx===target.x && ny===target.y)) continue;
      visited.add(k);
      q.push({x:nx,y:ny,path: node.path.concat(name)});
    }
  }
  return [];
}

// ---------------- Dijkstra (uniform weights) ----------------
function dijkstraPath(start, target, snakeBody){
  // Because weights are uniform, Dijkstra == BFS; but implement with priority queue style
  // We'll use a simple queue with distance map to simulate Dijkstra.
  const dist = new Map();
  const prev = new Map();
  function setDist(k,v){ dist.set(k,v); }
  function getDist(k){ return dist.has(k)?dist.get(k):Infinity; }
  const bodySet = new Set(snakeBody.map(s=>keyOf(s.x,s.y)));
  const startK = keyOf(start.x,start.y);
  setDist(startK,0);
  const q=[start];
  const visited = new Set();
  while(q.length){
    const node = q.shift();
    const nk = keyOf(node.x,node.y);
    if(visited.has(nk)) continue;
    visited.add(nk);
    if(node.x===target.x && node.y===target.y) break;
    for(const [dx,dy,name] of [[0,-1,'UP'],[0,1,'DOWN'],[-1,0,'LEFT'],[1,0,'RIGHT']]){
      const nx=node.x+dx, ny=node.y+dy;
      const k=keyOf(nx,ny);
      if(nx<0||nx>=gridSize||ny<0||ny>=gridSize) continue;
      if(bodySet.has(k) && !(nx===target.x && ny===target.y)) continue;
      if(getDist(k) > getDist(nk)+1){
        setDist(k,getDist(nk)+1);
        prev.set(k,{from:nk,move:name});
        q.push({x:nx,y:ny});
      }
    }
  }
  // reconstruct
  const targetK = keyOf(target.x,target.y);
  if(!prev.has(targetK) && !(start.x===target.x && start.y===target.y)) return [];
  const path=[];
  let cur = targetK;
  while(cur !== startK){
    const info = prev.get(cur);
    if(!info) break;
    path.unshift(info.move);
    cur = info.from;
  }
  return path;
}

// ---------------- A* search ----------------
function aStarPath(start, target, snakeBody){
  const bodySet = new Set(snakeBody.map(s=>keyOf(s.x,s.y)));
  function h(x,y){ return Math.abs(x-target.x)+Math.abs(y-target.y); } // Manhattan
  const open = new Map(); // key->node
  const closed = new Set();
  function key(x,y){ return keyOf(x,y); }
  const startK = key(start.x,start.y);
  open.set(startK, {x:start.x,y:start.y,g:0,f:h(start.x,start.y),parent:null,move:null});
  while(open.size){
    // pick lowest f
    let currentK, current;
    for(const [k,n] of open) {
      if(!current || n.f < current.f) { current = n; currentK = k; }
    }
    open.delete(currentK);
    if(current.x===target.x && current.y===target.y){
      // reconstruct path
      const out=[];
      let node=current;
      while(node.parent){
        out.unshift(node.move);
        node = node.parent;
      }
      return out;
    }
    closed.add(currentK);
    for(const [dx,dy,name] of [[0,-1,'UP'],[0,1,'DOWN'],[-1,0,'LEFT'],[1,0,'RIGHT']]){
      const nx=current.x+dx, ny=current.y+dy;
      const nk=key(nx,ny);
      if(nx<0||nx>=gridSize||ny<0||ny>=gridSize) continue;
      if(closed.has(nk)) continue;
      // treat body as obstacle except if target on body
      if(bodySet.has(nk) && !(nx===target.x && ny===target.y)) continue;
      const ng = current.g + 1;
      if(!open.has(nk) || ng < open.get(nk).g){
        open.set(nk, {x:nx,y:ny,g:ng,f:ng+h(nx,ny),parent:current,move:name});
      }
    }
  }
  return [];
}

// ---------------- Choose move by triple-check ----------------
function chooseAIMove(){
  if(!useAICheck.checked) return dir;
  // for each apple compute paths with A*, BFS, Dijkstra (in cell coords)
  const start = {x:snake[0].x, y:snake[0].y};
  const algPaths = []; // for visualization
  const depthLimit = Math.min(gridSize, 50);
  // find candidate paths per apple using A* (prefer), BFS, Dijkstra
  let candidates = []; // {apple,pathA,pathB,pathC}
  for(const apple of apples){
    const pathA = aStarPath(start, apple, snake);
    const pathB = bfsPath(start, apple, snake);
    const pathC = dijkstraPath(start, apple, snake);
    // store only if any path found
    if(pathA.length || pathB.length || pathC.length){
      candidates.push({ apple, pathA, pathB, pathC });
      algPaths.push({apple, pathA, pathB, pathC});
    }
  }
  // Evaluate first moves of each algorithm to get majority or fallback
  let moveVotes = {}; // move->count
  let candidateMoves = []; // store best candidate object with chosen move and path used
  for(const c of candidates){
    // pick primary path preference order: A* > BFS > Dijkstra (but we will count all three)
    const firstA = c.pathA[0] || null;
    const firstB = c.pathB[0] || null;
    const firstC = c.pathC[0] || null;
    // record votes
    [firstA, firstB, firstC].forEach(m => { if(m){ moveVotes[m] = (moveVotes[m]||0)+1; } });
    candidateMoves.push({apple:c.apple, pathA:c.pathA, pathB:c.pathB, pathC:c.pathC});
  }

  // if no candidates fallback safe move
  if(candidateMoves.length===0){
    return safeFallbackMove();
  }

  // determine majority move among all first steps across all apples
  let bestMove=null, bestVotes=0;
  for(const m of Object.keys(moveVotes)){
    if(moveVotes[m] > bestVotes){ bestVotes = moveVotes[m]; bestMove = m; }
  }
  // If majority (>=2 votes) picked a move â€” verify it's safe and choose it
  if(bestMove && bestVotes >= 2){
    // ensure the move is safe (not directly colliding)
    if(isMoveSafe(bestMove)) return bestMove;
  }

  // otherwise, evaluate candidates by safety heuristic: after following path (truncate at depthLimit) measure flood-fill
  let bestScore=-Infinity, bestChoice=null, bestChoicePath=[];
  for(const c of candidateMoves){
    // prefer shortest available non-empty path (choose A*/BFS/Dijkstra path order)
    let chosenPath = c.pathA.length ? c.pathA : (c.pathB.length ? c.pathB : c.pathC);
    if(!chosenPath || chosenPath.length===0) continue;
    // simulate following up to depthLimit steps on chosenPath
    let simSnake = snake.map(s=>({x:s.x,y:s.y}));
    let simHead = {x:simSnake[0].x, y:simSnake[0].y};
    const steps = Math.min(chosenPath.length, depthLimit);
    for(let i=0;i<steps;i++){
      const mv = chosenPath[i];
      const dxy = DIRS[mv];
      simHead = { x: simHead.x + dxy[0], y: simHead.y + dxy[1] };
      simSnake.unshift({x: simHead.x, y: simHead.y});
      simSnake.pop();
    }
    // compute free space reachable
    const free = floodFillCount(simHead.x, simHead.y, simSnake, 2000);
    // penalize if path leads to immediate collision or out of bounds
    const valid = chosenPath.length>0 && isPathValid(chosenPath, snake);
    const score = (valid ? 1000 + free : -10000) - chosenPath.length; // prefer valid, then more free space, shorter path
    if(score > bestScore){
      bestScore = score;
      bestChoice = chosenPath[0];
      bestChoicePath = chosenPath;
    }
  }

  // For visualization store last algPaths globally
  lastAlgPaths = algPaths;
  // if bestChoice safe, return else fallback
  if(bestChoice && isMoveSafe(bestChoice)) return bestChoice;
  return safeFallbackMove();
}

// ---------------- check path validity quickly ----------------
function isPathValid(path, baseSnake){
  let head = {x: baseSnake[0].x, y: baseSnake[0].y};
  const occupied = new Set(baseSnake.map(s=>keyOf(s.x,s.y)));
  for(const mv of path){
    const dxy = DIRS[mv];
    head = { x: head.x + dxy[0], y: head.y + dxy[1] };
    if(head.x<0||head.x>=gridSize||head.y<0||head.y>=gridSize) return false;
    // allow stepping on apple cell; disallow stepping on body
    if(occupied.has(keyOf(head.x,head.y))) return false;
    // simulate tail movement (pop)
    const tail = baseSnake[baseSnake.length-1];
    occupied.delete(keyOf(tail.x,tail.y));
  }
  return true;
}

// ---------------- safe fallback move ----------------
function safeFallbackMove(){
  // return first safe direction
  for(const mv of ['UP','RIGHT','DOWN','LEFT']){
    if(isMoveSafe(mv)) return mv;
  }
  return dir; // no safe move (will die)
}

// ---------------- check whether a single move is safe
function isMoveSafe(mv){
  const dxy = DIRS[mv];
  const nx = snake[0].x + dxy[0];
  const ny = snake[0].y + dxy[1];
  if(nx<0||nx>=gridSize||ny<0||ny>=gridSize) return false;
  if(collidesWithSnake(nx,ny)) return false;
  return true;
}

// ---------------- game tick ----------------
let lastAlgPaths = []; // for visualization
function tick(){
  // compute next direction
  if(useAICheck.checked){
    dir = chooseAIMove();
  }
  // next head cell
  const dxy = DIRS[dir];
  const nx = snake[0].x + dxy[0];
  const ny = snake[0].y + dxy[1];
  const newHead = {x:nx,y:ny};

  // collision?
  if(nx<0||nx>=gridSize||ny<0||ny>=gridSize || collidesWithSnake(nx,ny)){
    clearInterval(gameTimer);
    SND_DEAD.play().catch(()=>{});
    overlayText.textContent = 'You Died!';
    overlay.style.display = 'flex';
    return;
  }

  // check if eats apple
  let ate=false;
  for(let i=0;i<apples.length;i++){
    if(apples[i].x===nx && apples[i].y===ny){
      ate=true;
      score++;
      scoreEl.textContent = score;
      SND_EAT.play().catch(()=>{});
      apples.splice(i,1);
      spawnApple(); // refill
      break;
    }
  }

  // move snake
  snake.unshift(newHead);
  if(!ate) snake.pop();

  // win check: snake occupies all cells (rare)
  if(snake.length >= gridSize*gridSize){
    clearInterval(gameTimer);
    overlayText.textContent = 'You Won!';
    overlay.style.display = 'flex';
    return;
  }

  // draw
  drawEverything();
}

// ---------------- Drawing ----------------
function drawEverything(){
  // background
  ctx.fillStyle = '#111';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // show algorithm paths if enabled
  if(showPathCheck.checked && lastAlgPaths.length){
    for(const pinfo of lastAlgPaths){
      // A* path blue
      if(pinfo.pathA && pinfo.pathA.length){
        drawPath(pinfo.pathA, '#2ec4ff', 0.35);
      }
      // BFS cyan
      if(pinfo.pathB && pinfo.pathB.length){
        drawPath(pinfo.pathB, '#00ffcc', 0.28);
      }
      // Dijkstra yellow
      if(pinfo.pathC && pinfo.pathC.length){
        drawPath(pinfo.pathC, '#ffd166', 0.22);
      }
    }
  }

  // apples
  for(const a of apples){
    const px = a.x*box, py = a.y*box;
    ctx.fillStyle = '#ff4d4d';
    ctx.fillRect(px,py,box,box);
    ctx.strokeStyle = '#8b0000';
    ctx.strokeRect(px+1,py+1,box-2,box-2);
  }

  // snake
  for(let i=snake.length-1;i>=0;i--){
    const s = snake[i];
    const px = s.x*box, py = s.y*box;
    ctx.fillStyle = (i===0)?'#0077ff':'#8fcfff';
    ctx.fillRect(px,py,box,box);
    ctx.strokeStyle = '#003f66';
    ctx.strokeRect(px+1,py+1,box-2,box-2);
  }
}

// helper draw path (direction array)
function drawPath(path,color,alpha=0.3){
  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.fillStyle = color;
  let pos = { x: snake[0].x, y: snake[0].y };
  for(const mv of path){
    pos = { x: pos.x + DIRS[mv][0], y: pos.y + DIRS[mv][1] };
    ctx.fillRect(pos.x*box + box*0.25, pos.y*box + box*0.25, box*0.5, box*0.5);
  }
  ctx.restore();
}

// ---------------- Manual controls ----------------
document.addEventListener('keydown', (e)=>{
  if(useAICheck.checked) return; // ignore manual if AI on
  if(e.key === 'ArrowUp' && dir !== 'DOWN') dir = 'UP';
  if(e.key === 'ArrowDown' && dir !== 'UP') dir = 'DOWN';
  if(e.key === 'ArrowLeft' && dir !== 'RIGHT') dir = 'LEFT';
  if(e.key === 'ArrowRight' && dir !== 'LEFT') dir = 'RIGHT';
});

// ---------------- UI bindings ----------------
playAgainBtn.addEventListener('click', ()=>initGame());
overlayBtn.addEventListener('click', ()=>initGame());
speedRange.addEventListener('input', ()=>setSpeed(parseInt(speedRange.value)));
mapSizeInput.addEventListener('change', ()=>initGame());
appleInput.addEventListener('change', ()=>initGame());
useAICheck.addEventListener('change', ()=>{}); // noop
showPathCheck.addEventListener('change', ()=>{}); // noop

// ---------------- Start ----------------
initGame();
</script>
</body>
</html>
