<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Blue Snake AI</title>
<style>
  :root {--bg:#111;--panel:#222;--accent:#00aaff;}
  body {margin:0;font-family:Arial,Helvetica,sans-serif;background:var(--panel);color:#fff;display:flex;flex-direction:column;align-items:center;padding:18px;}
  h1 {margin:6px 0 14px 0;}
  .controls {display:flex;flex-wrap:wrap;gap:10px;align-items:center;justify-content:center;}
  label {font-size:14px;}
  input[type="number"] {width:60px;padding:4px;border-radius:4px;border:none;text-align:center;}
  input[type="range"] {width:180px;}
  button {background:var(--accent);color:#04111a;border:none;padding:8px 12px;border-radius:6px;cursor:pointer;}
  button:hover {opacity:.95;}
  #gameArea {position:relative;margin-top:12px;}
  canvas {background:var(--bg);border:3px solid var(--accent);border-radius:8px;display:block;}
  #hud {margin-top:10px;display:flex;gap:12px;align-items:center;}
  #overlay {position:absolute;left:0;top:0;width:100%;height:100%;background:rgba(0,0,0,0.75);display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:5;display:none;}
  #overlayText {font-size:48px;margin-bottom:12px;}
  #calcPanel {font-size:12px;line-height:1.2;white-space:pre;max-height:200px;overflow:auto;margin-top:8px;width:640px;max-width:90%;}
</style>
</head>
<body>
<h1>Blue Snake AI</h1>

<div class="controls">
  <label>Map size: <input id="mapSize" type="number" min="5" max="80" value="15"></label>
  <label>Apples: <input id="appleCount" type="number" min="1" max="50" value="5"></label>
  <label>Mode: 
    <select id="aiMode">
      <option value="safe">Safe</option>
      <option value="greedy">Greedy</option>
    </select>
  </label>
  <label>Speed: <input id="speed" type="range" min="30" max="300" value="120"> <span id="speedVal">120ms</span></label>
  <button id="playAgain">Play Again</button>
  <button id="pauseBtn">Pause</button>
  <button id="trainBtn">Train</button>
  <button id="toggleCalcBtn">Show AI Calculations</button>
  <button id="clearDataBtn">Clear Learning Data</button>
</div>

<div id="gameArea">
  <canvas id="canvas"></canvas>
  <div id="overlay"><div id="overlayText"></div><button id="overlayBtn">Play Again</button></div>
</div>

<div id="hud">
  <div>Score: <span id="score">0</span></div>
  <div>Avg: <span id="avg">0</span></div>
</div>

<div id="calcPanel" style="display:none"></div>

<script>
// ----- Elements -----
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const mapSizeInput = document.getElementById('mapSize');
const appleInput = document.getElementById('appleCount');
const aiModeSelect = document.getElementById('aiMode');
const playAgainBtn = document.getElementById('playAgain');
const overlay = document.getElementById('overlay');
const overlayText = document.getElementById('overlayText');
const overlayBtn = document.getElementById('overlayBtn');
const scoreEl = document.getElementById('score');
const avgScoreEl = document.getElementById('avg');
const speedRange = document.getElementById('speed');
const speedVal = document.getElementById('speedVal');
const pauseBtn = document.getElementById('pauseBtn');
const trainBtn = document.getElementById('trainBtn');
const calcPanel = document.getElementById('calcPanel');
const toggleCalcBtn = document.getElementById('toggleCalcBtn');
const clearDataBtn = document.getElementById('clearDataBtn');

// ----- Sounds -----
const SND_EAT = new Audio('/sound/eated.mp3');
const SND_DEAD = new Audio('/sound/gameover.mp3');

// ----- Config -----
let box = 32, gridSize, appleCount, snake, apples, dir, gameTimer=null, intervalMs=120, score=0;
let paused=false, trainingEnabled=false;
let debugPaths=[], debugScores=[];
const DIRS={UP:[0,-1],DOWN:[0,1],LEFT:[-1,0],RIGHT:[1,0]};
let learningData={}, tempLearning={};
let avgScore=0, gamesPlayed=0;

// ----- Utils -----
function keyOf(x,y){return `${x},${y}`;}
function collidesWithSnake(x,y){return snake.some(s=>s.x===x && s.y===y);}

// ----- Canvas setup -----
function setupCanvas(){
  gridSize = Math.max(5,Math.min(50,parseInt(mapSizeInput.value)||15));
  appleCount = Math.max(1,Math.min(20,parseInt(appleInput.value)||5));
  box = Math.max(12,Math.floor(640/gridSize));
  canvas.width = canvas.height = box*gridSize;
  calcPanel.style.width = Math.min(640, box*gridSize) + 'px';
}

// ----- Spawn apple -----
function spawnApple(){
  let attempts=0;
  while(attempts<2000){
    const x=Math.floor(Math.random()*gridSize), y=Math.floor(Math.random()*gridSize);
    if(!collidesWithSnake(x,y) && !apples.some(a=>a.x===x&&a.y===y)){
      apples.push({x,y});
      return;
    }
    attempts++;
  }
}

// ----- Flood Fill -----
function floodFillCount(sx,sy,snakeBody,limit=1000){
  const visited=new Set(), bodySet=new Set(snakeBody.map(s=>keyOf(s.x,s.y)));
  const q=[{x:sx,y:sy}]; let cnt=0;
  while(q.length && cnt<limit){
    const p=q.shift(); const k=keyOf(p.x,p.y);
    if(visited.has(k)) continue;
    if(p.x<0||p.x>=gridSize||p.y<0||p.y>=gridSize) continue;
    if(bodySet.has(k)) continue;
    visited.add(k); cnt++;
    q.push({x:p.x+1,y:p.y}); q.push({x:p.x-1,y:p.y});
    q.push({x:p.x,y:p.y+1}); q.push({x:p.x,y:p.y-1});
  }
  return cnt;
}

// ----- A* Pathfinding -----
function aStarPath(start,target,snakeBody){
  const bodySet=new Set(snakeBody.map(s=>keyOf(s.x,s.y)));
  const h=(x,y)=>Math.abs(x-target.x)+Math.abs(y-target.y);
  const open=new Map(), closed=new Set();
  open.set(keyOf(start.x,start.y), {x:start.x,y:start.y,g:0,f:h(start.x,start.y),parent:null,move:null});
  while(open.size){
    let current, currentK;
    for(const [k,n] of open){if(!current || n.f<current.f){current=n; currentK=k;}}
    open.delete(currentK); closed.add(currentK);
    if(current.x===target.x && current.y===target.y){
      const out=[]; let node=current;
      while(node.parent){ out.unshift(node.move); node=node.parent; }
      return out;
    }
    for(const [dx,dy,name] of [[0,-1,'UP'],[0,1,'DOWN'],[-1,0,'LEFT'],[1,0,'RIGHT']]){
      const nx=current.x+dx, ny=current.y+dy;
      if(nx<0||nx>=gridSize||ny<0||ny>=gridSize) continue;
      if(closed.has(keyOf(nx,ny))) continue;
      if(bodySet.has(keyOf(nx,ny)) && !(nx===target.x&&ny===target.y)) continue;
      const ng=current.g+1;
      if(!open.has(keyOf(nx,ny)) || ng<open.get(keyOf(nx,ny)).g){
        open.set(keyOf(nx,ny),{x:nx,y:ny,g:ng,f:ng+h(nx,ny),parent:current,move:name});
      }
    }
  }
  return [];
}

// ----- AI Move -----
function safeFallbackMove(){
  for(const mv of ['UP','RIGHT','DOWN','LEFT']){
    const d=DIRS[mv]; const nx=snake[0].x+d[0], ny=snake[0].y+d[1];
    if(nx>=0 && nx<gridSize && ny>=0 && ny<gridSize && !collidesWithSnake(nx,ny)) return mv;
  }
  return dir;
}

function chooseAIMove(){
  debugPaths=[]; debugScores=[];
  const stateKey=getStateKey();
  const forbiddenMoves = learningData[stateKey]||[];
  const start={x:snake[0].x,y:snake[0].y};
  let bestScore=-Infinity, bestMove=null, bestPath=[];
  for(const apple of apples){
    const path=aStarPath(start,apple,snake);
    if(!path.length) continue;
    let simSnake = snake.map(s=>({x:s.x,y:s.y})), simHead={x:simSnake[0].x,y:simSnake[0].y};
    const pathScores=[];
    path.forEach((mv)=>{
      const dxy=DIRS[mv];
      simHead={x:simHead.x+dxy[0],y:simHead.y+dxy[1]};
      simSnake.unshift({...simHead}); simSnake.pop();
      let scoreVal=0;
      if(aiModeSelect.value==='safe'){
        scoreVal+=10;
        if(collidesWithSnake(simHead.x,simHead.y)) scoreVal-=15;
      }
      pathScores.push(scoreVal);
    });
    debugPaths.push({path,apple,isChosen:false});
    debugScores.push({path,apple,pathScores});
    const finalScore=pathScores[pathScores.length-1]||0;
    if(finalScore>bestScore && !forbiddenMoves.includes(path[0])){
      bestScore=finalScore; bestMove=path[0]; bestPath=path;
    }
  }
  debugPaths.forEach(p=>p.isChosen=(p.path===bestPath));
  if(!bestMove && trainingEnabled){
    const fallback=safeFallbackMove();
    if(fallback){if(!tempLearning[stateKey]) tempLearning[stateKey]=[]; tempLearning[stateKey].push(fallback);}
  }
  return bestMove||safeFallbackMove();
}

function getStateKey(){return `${snake[0].x},${snake[0].y}|${apples.map(a=>`${a.x},${a.y}`).join('|')}|${snake.length}`;}

// ----- Tick -----
function tick(){
  if(paused) return;
  dir=chooseAIMove();
  const dxy=DIRS[dir], nx=snake[0].x+dxy[0], ny=snake[0].y+dxy[1];
  const newHead={x:nx,y:ny};
  if(nx<0||nx>=gridSize||ny<0||ny>=gridSize||collidesWithSnake(nx,ny)){
    if(gameTimer){ clearInterval(gameTimer); gameTimer=null; }
    overlayText.textContent=`You Died! Score: ${score}`;
    overlay.style.display='flex';
    SND_DEAD.play();
    gamesPlayed++; avgScore=(avgScore*(gamesPlayed-1)+score)/gamesPlayed;
    avgScoreEl.textContent=avgScore.toFixed(2);
    if(trainingEnabled) autoRetry();
    return;
  }
  let ate=false;
  for(let i=0;i<apples.length;i++){
    if(apples[i].x===nx && apples[i].y===ny){
      ate=true; score++; scoreEl.textContent=score;
      SND_EAT.play();
      apples.splice(i,1); spawnApple(); break;
    }
  }
  snake.unshift(newHead); if(!ate) snake.pop();
  if(snake.length>=gridSize*gridSize){
    if(gameTimer){ clearInterval(gameTimer); gameTimer=null; }
    overlayText.textContent='You Won!';
    overlay.style.display='flex';
    gamesPlayed++; avgScore=(avgScore*(gamesPlayed-1)+score)/gamesPlayed;
    avgScoreEl.textContent=avgScore.toFixed(2);
    if(trainingEnabled) autoRetry();
    return;
  }
  drawEverything();
}

// ----- Draw -----
function drawEverything(){/* unchanged */}
function autoRetry(){ if(trainingEnabled) setTimeout(initGame,0); }
document.addEventListener('keydown',/* unchanged */);
playAgainBtn.addEventListener('click',()=>initGame());
overlayBtn.addEventListener('click',()=>initGame());
speedRange.addEventListener('input',/* unchanged */);
pauseBtn.addEventListener('click',()=>paused=!paused);
toggleCalcBtn.addEventListener('click',/* unchanged */);
trainBtn.addEventListener('click',/* unchanged */);
function trainingLoop(){/* unchanged */}
function initGame(){/* unchanged */}

initGame();
</script>
</body>
</html>
